# 補正変換パイプライン

## 概要

Switch 2 の GameCube Classics 環境では、コントローラのアナログスティック入力に対して非線形な座標変換 S が適用される。
この変換は実機（GameCube / Wii）とは異なるため、スティック操作に違和感が生じる。

本ドキュメントでは、Pico ブリッジで S を打ち消すための補正パイプライン **P(s) = S⁻¹⁺(φ(C(s)))** を定義する。
補正が成功していれば、ゲームが受け取る値 S(P(s)) は目標値 φ(C(s)) に近くなる。

入力データ: `readings.csv`（65,536 点の計測結果）。生成方法は [docs/measurements.md](measurements.md) を参照。

## 記号の定義

| 記号 | 定義 | 値域 |
|---|---|---|
| s = (sx, sy) | コントローラの生入力 | [0, 255]² |
| S(s) | Switch 2 の非線形変換 | readings.csv から構築 |
| m = S(s) = (gx+128, gy+128) | ゲーム受信座標 | [0, 255]² |
| Oct(a) | 正八角形（半径 a） | 頂点が 0°, 45°, 90°, ... 方向に距離 a |
| C(s) | Oct(125) への放射クランプ | Oct 内はそのまま、外は境界に射影 |
| φ(s) | 線形スケーリング | `k · (s − 128) + 128`, k = 0.8 |
| S⁻¹(m) | S の逆変換 | S(s) = m となる s |
| S⁻¹⁺(m) | ギャップ補間付き逆変換 | BFS 最近傍で全セルに原像を割当 |
| P(s) = S⁻¹⁺(φ(C(s))) | Pico 補正パイプライン全体 | [0, 255]² |

## 正八角形 Oct(a)

GC コントローラの物理的なスティックゲートは正八角形に近い形状をしている。
Oct(a) は中心 (128, 128) に対し、0°, 45°, 90°, 135°, ... の 8 方向に頂点を持つ正八角形として定義する。

頂点座標（中心からの相対値）:

```
(a, 0), (a/√2, a/√2), (0, a), (-a/√2, a/√2),
(-a, 0), (-a/√2, -a/√2), (0, -a), (a/√2, -a/√2)
```

### アポテム

アポテム（中心から辺への垂直距離）は `h = a · cos(π/8)` である。

定数: `cos(π/8) ≈ 0.924`, `sin(π/8) ≈ 0.383`

### 内外判定

点 (cx, cy)（中心基準）が Oct(a) の内部にあるかどうかは、4 つの半平面制約で判定する:

```
|cos(π/8) · cx + sin(π/8) · cy| ≤ h
|cos(π/8) · cx − sin(π/8) · cy| ≤ h
|sin(π/8) · cx + cos(π/8) · cy| ≤ h
|sin(π/8) · cx − cos(π/8) · cy| ≤ h
```

4 つすべてを満たせば内部、1 つでも超えれば外部。

### 2 つの八角形

| 八角形 | 半径 | 意味 |
|---|---|---|
| Oct(125) | 125 | 物理ゲートの境界（コントローラが出力しうる最大範囲） |
| Oct(100) | 100 | ソフトウェアが期待する入力範囲 |

## S: Switch 2 の非線形変換

readings.csv の各行 `(frame, sx, sy, gx, gy)` は、コントローラが送信した `(sx, sy)` に対しゲームが受け取った座標 `(gx, gy)` を記録している。

256×256 のルックアップテーブルとして構築する:

```
S[sx][sy] = (gx + 128, gy + 128)
```

ここで gx, gy ∈ [-128, 127] を [0, 255] へシフトし、配列インデックスとして扱えるようにしている。

性質:
- 非線形: 入力空間の等間隔グリッドが出力空間では歪む
- 多対一: 異なる入力が同じ出力にマッピングされる場合がある（逆変換でギャップが生じる原因）

## C: Oct(125) への放射クランプ

物理スティックは Oct(125) の外側まで動ける場合がある。ソフトウェア処理前にこれを Oct(125) 境界にクランプする。

アルゴリズム:

```
1. 中心基準の座標を計算: px = sx − 128, py = sy − 128
2. 4 つの半平面比の最大値 t を求める:
   t = max(
       |cos(π/8)·px + sin(π/8)·py| / h,
       |cos(π/8)·px − sin(π/8)·py| / h,
       |sin(π/8)·px + cos(π/8)·py| / h,
       |sin(π/8)·px − cos(π/8)·py| / h
   )
   ここで h = 125 · cos(π/8)
3. t ≤ 1 → Oct(125) 内部。そのまま返す
4. t > 1 → 放射方向に 1/t に縮小して境界に射影:
   C(s) = (px/t + 128, py/t + 128)
```

## φ: 線形スケーリング

Oct(125)（物理範囲）を Oct(100)（ソフトウェア期待範囲）に線形縮小する。

```
φ(s) = k · (s − 128) + 128
k = 100 / 125 = 0.8
```

中心 (128, 128) は不動点。Oct(125) の境界が Oct(100) の境界に写る。

## S⁻¹: S の逆変換

S の逆変換テーブル INV_S を構築する。S_DATA の全エントリを走査し、出力座標をキーにして入力座標を格納する:

```
for (sx, sy) in [0, 255]²:
    (mx, my) = S[sx][sy]
    INV_S[mx][my] = (sx, sy)
```

同じ (mx, my) に複数の (sx, sy) がマッピングされる場合は後勝ち。
逆に、どの入力からも到達しない出力座標はギャップ（原像なし）となり、`null` のまま残る。

## S⁻¹⁺: ギャップ補間付き逆変換

S⁻¹ のギャップを BFS（幅優先探索）で最近傍補間して埋める。

アルゴリズム:

```
1. INV_S をコピーして INV_SF を作成
2. INV_S[mx][my] ≠ null であるすべてのセルをキューに入れる
3. BFS（4 連結: 上下左右）でキューを処理:
   - 隣接セル (nx, ny) が null なら、現在セルの値をコピー
   - (nx, ny) をキューに追加
4. 全セルに値が割り当てられるまで繰り返す
```

結果:
- `INV_SF[mx][my]`: 全セルに有効な原像が入った 256×256 テーブル
- `EXACT[mx][my]`: `true` = S⁻¹ で直接得られた原像、`false` = BFS 補間

マンハッタン距離が最小の正確な原像を採用するため、BFS の到達順が距離順に一致する。

## S ∘ S⁻¹⁺: 往復検証

S⁻¹⁺ の品質を検証するため、逆変換した結果に S を再適用して元の座標に戻るか確認する。

```
入力: m
往復結果: S(S⁻¹⁺(m))
誤差: ‖S(S⁻¹⁺(m)) − m‖  （ユークリッド距離）
```

誤差が 0 なら完全な逆変換。補間点では誤差が生じるが、小さいほど補間品質が高い。

可視化ツールでは誤差をヒートマップ（緑 = 0、赤 = 5 以上）で表示する。

## P: Pico 補正パイプライン

コントローラの生入力 s に対し、Pico が出力すべき補正値を以下のパイプラインで求める:

```
P(s) = S⁻¹⁺(φ(C(s)))
```

ステップごとの流れ:

```
s                          元のスティック入力
  ↓ C
C(s)                       Oct(125) にクランプ
  ↓ φ
φ(C(s))                    Oct(100) にスケーリング（= ゲームに届けたい目標値）
  ↓ round → S⁻¹⁺
S⁻¹⁺(round(φ(C(s))))      S を打ち消す入力値（= Pico が送信する値）
```

φ と C は浮動小数を返すが、S⁻¹⁺ は整数インデックスのルックアップテーブルであるため、`round()` で丸めてから参照する。

### 検証

Pico の出力 P(s) が Switch 2 に渡ると S が適用され、ゲームは `S(P(s))` を受け取る。

```
目標: S(P(s)) ≈ φ(C(s))
誤差: ‖S(P(s)) − φ(C(s))‖  （ユークリッド距離）
```

誤差が小さければ、補正パイプラインは意図通りに機能している。

## 可視化ツール

`tools/visualize_transforms.py` は readings.csv を読み込み、上記の変換をすべてインタラクティブに確認できるスタンドアロン HTML を生成する。

実行:

```bash
uv run tools/visualize_transforms.py \
    --input resources/switch2/20260205/readings.csv \
    --output resources/switch2/20260205/transform_viewer.html
```

### タブ一覧

| タブ | 内容 |
|---|---|
| S | マウス位置 s に対し S(s) を表示 |
| S⁻¹ | マウス位置 m に対し S⁻¹(m) を表示（原像なしは赤背景） |
| S⁻¹⁺ | BFS 補間付き逆変換（補間点はギャップ色で区別） |
| S∘S⁻¹⁺ | 往復誤差のヒートマップ（緑→赤） |
| P | 補正パイプライン全体: s → C(s) → φ(C(s)) → P(s) → S(P(s)) |
| C | Oct(125) への放射クランプの入出力 |
| φ | 線形スケーリングの入出力 |

各タブではマウスホバーで入力座標に対応する出力が点・ラベル・破線で表示される。
ライト/ダークモードはシステム設定に自動追従する。
