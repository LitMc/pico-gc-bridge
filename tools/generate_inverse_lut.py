"""readings.csv から S⁻¹⁺ (BFS補間付き逆変換) の C++ LUT ヘッダを生成する。

Usage:
    uv run tools/generate_inverse_lut.py \
        --input resources/switch2/20260205/readings.csv \
        --output examples/bridge/domain/transform/inverse_lut_data.hpp
"""

import argparse
import csv
import math
import sys
from collections import deque
from datetime import datetime, timezone
from pathlib import Path

N = 256


def read_s_data(path: Path) -> list[list[tuple[int, int] | None]]:
    """readings.csv を読み込み S[sx][sy] = (gx+128, gy+128) を構築する。"""
    s_data: list[list[tuple[int, int] | None]] = [
        [None] * N for _ in range(N)
    ]
    with open(path, newline="") as f:
        reader = csv.DictReader(f)
        count = 0
        skipped = 0
        for line_no, row in enumerate(reader, start=2):
            sx = int(row["sx"])
            sy = int(row["sy"])
            if not (0 <= sx < N and 0 <= sy < N):
                print(f"警告: 行{line_no} の sx/sy が範囲外です (sx={sx}, sy={sy})。スキップします", file=sys.stderr)
                skipped += 1
                continue
            gx = int(row["gx"])
            gy = int(row["gy"])
            mx = gx + 128
            my = gy + 128
            s_data[sx][sy] = (mx, my)
            count += 1
    if skipped > 0:
        print(f"警告: {skipped} 行をスキップしました（範囲外の sx/sy）", file=sys.stderr)
    print(f"読み込み: {count} 行 ({path})")
    return s_data


def build_inverse(
    s_data: list[list[tuple[int, int] | None]],
) -> list[list[tuple[int, int] | None]]:
    """S の逆変換テーブル INV_S を構築する（後勝ち）。"""
    inv_s: list[list[tuple[int, int] | None]] = [[None] * N for _ in range(N)]
    for sx in range(N):
        for sy in range(N):
            entry = s_data[sx][sy]
            if entry is None:
                continue
            mx, my = entry
            if 0 <= mx < N and 0 <= my < N:
                inv_s[mx][my] = (sx, sy)
    return inv_s


def bfs_fill(
    inv_s: list[list[tuple[int, int] | None]],
) -> tuple[list[list[tuple[int, int]]], list[list[bool]], int]:
    """BFS 4連結でギャップを補間し、全セルに原像を割り当てる。"""
    inv_sf: list[list[tuple[int, int] | None]] = [
        [cell for cell in row] for row in inv_s
    ]
    exact: list[list[bool]] = [
        [cell is not None for cell in row] for row in inv_s
    ]

    queue: deque[tuple[int, int]] = deque()
    for mx in range(N):
        for my in range(N):
            if inv_s[mx][my] is not None:
                queue.append((mx, my))

    max_distance = 0
    distance: list[list[int]] = [[0] * N for _ in range(N)]
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    while queue:
        mx, my = queue.popleft()
        for dx, dy in directions:
            nx, ny = mx + dx, my + dy
            if 0 <= nx < N and 0 <= ny < N and inv_sf[nx][ny] is None:
                inv_sf[nx][ny] = inv_sf[mx][my]
                d = distance[mx][my] + 1
                distance[nx][ny] = d
                if d > max_distance:
                    max_distance = d
                queue.append((nx, ny))

    # 型アサーション: 全セルが埋まっているはず
    result: list[list[tuple[int, int]]] = []
    for row in inv_sf:
        result_row: list[tuple[int, int]] = []
        for cell in row:
            assert cell is not None, "BFS 補間後に None が残っている"
            result_row.append(cell)
        result.append(result_row)

    return result, exact, max_distance


def compute_roundtrip_stats(
    s_data: list[list[tuple[int, int] | None]],
    inv_sf: list[list[tuple[int, int]]],
) -> tuple[float, float, int]:
    """往復誤差 ||S(S⁻¹⁺(m)) - m|| の統計を計算する。"""
    total_error = 0.0
    max_error = 0.0
    count = 0
    for mx in range(N):
        for my in range(N):
            sx, sy = inv_sf[mx][my]
            entry = s_data[sx][sy]
            if entry is None:
                continue
            mx2, my2 = entry
            error = math.sqrt((mx2 - mx) ** 2 + (my2 - my) ** 2)
            total_error += error
            if error > max_error:
                max_error = error
            count += 1
    mean_error = total_error / count if count > 0 else 0.0
    return max_error, mean_error, count


def emit_header(
    s_data: list[list[tuple[int, int] | None]],
    inv_sf: list[list[tuple[int, int]]],
    exact: list[list[bool]],
    input_path: Path,
    output_path: Path,
) -> None:
    """C++ ヘッダファイルを生成する。"""
    now = datetime.now(timezone.utc).strftime("%Y-%m-%dT%H:%M:%SZ")

    exact_count = sum(1 for row in exact for cell in row if cell)
    gap_count = N * N - exact_count

    with open(output_path, "w") as f:
        f.write(f"// Auto-generated by tools/generate_inverse_lut.py\n")
        f.write(f"// Source: {input_path}\n")
        f.write(f"// Generated: {now}\n")
        f.write(f"// Exact preimages: {exact_count}, BFS-interpolated: {gap_count}\n")
        f.write(f"#pragma once\n")
        f.write(f"#include <cstdint>\n")
        f.write(f"\n")
        f.write(f"namespace gcinput::domain::transform::correction {{\n")
        f.write(f"\n")

        # S⁻¹⁺ 逆変換テーブル
        for name, channel in [("kInverseLutX", 0), ("kInverseLutY", 1)]:
            f.write(f"// clang-format off\n")
            f.write(f"inline constexpr uint8_t {name}[{N}][{N}] = {{\n")
            for mx in range(N):
                values = [str(inv_sf[mx][my][channel]) for my in range(N)]
                line = ",".join(values)
                f.write(f"  {{{line}}},\n")
            f.write(f"}};\n")
            f.write(f"// clang-format on\n")
            f.write(f"\n")

        # S 順方向テーブル（デバッグ用）
        for name, channel in [("kForwardLutX", 0), ("kForwardLutY", 1)]:
            f.write(f"// clang-format off\n")
            f.write(f"inline constexpr uint8_t {name}[{N}][{N}] = {{\n")
            for sx in range(N):
                values = []
                for sy in range(N):
                    entry = s_data[sx][sy]
                    if entry is not None:
                        values.append(str(entry[channel]))
                    else:
                        values.append("128")
                line = ",".join(values)
                f.write(f"  {{{line}}},\n")
            f.write(f"}};\n")
            f.write(f"// clang-format on\n")
            f.write(f"\n")

        f.write(f"}} // namespace gcinput::domain::transform::correction\n")


def main() -> None:
    parser = argparse.ArgumentParser(
        description="readings.csv から S⁻¹⁺ の C++ LUT ヘッダを生成する"
    )
    parser.add_argument(
        "--input",
        type=Path,
        required=True,
        help="readings.csv のパス",
    )
    parser.add_argument(
        "--output",
        type=Path,
        required=True,
        help="出力する C++ ヘッダのパス",
    )
    args = parser.parse_args()

    if not args.input.exists():
        print(f"エラー: {args.input} が見つかりません", file=sys.stderr)
        sys.exit(1)

    # S テーブル構築
    s_data = read_s_data(args.input)

    # 逆変換テーブル構築
    inv_s = build_inverse(s_data)
    exact_count = sum(1 for row in inv_s for cell in row if cell is not None)
    gap_count = N * N - exact_count
    print(f"INV_S: 正確な原像 {exact_count}, ギャップ {gap_count}")

    if exact_count == 0:
        print("エラー: 逆変換テーブルにシードが1つもありません。入力CSVが空か全欠損です", file=sys.stderr)
        sys.exit(1)

    # BFS 補間
    inv_sf, exact, max_distance = bfs_fill(inv_s)
    print(f"BFS 補間完了: 最大距離 {max_distance}")

    # 往復誤差
    max_error, mean_error, count = compute_roundtrip_stats(s_data, inv_sf)
    print(f"往復誤差: max={max_error:.3f}, mean={mean_error:.3f} ({count} セル)")

    # C++ ヘッダ出力
    args.output.parent.mkdir(parents=True, exist_ok=True)
    emit_header(s_data, inv_sf, exact, args.input, args.output)
    print(f"出力: {args.output}")


if __name__ == "__main__":
    main()
